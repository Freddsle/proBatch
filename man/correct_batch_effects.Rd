% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/correct_batch_effects.R
\name{correct_batch_effects}
\alias{correct_batch_effects}
\alias{adjust_batch_trend_dm}
\alias{adjust_batch_trend_df}
\title{Batch correction methods for normalized data}
\usage{
adjust_batch_trend_dm(
  data_matrix,
  sample_annotation,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  fit_func = "loess_regression",
  return_fit_df = TRUE,
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

adjust_batch_trend_df(
  df_long,
  sample_annotation = NULL,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  fit_func = "loess_regression",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

correct_batch_effects(
  x,
  sample_annotation,
  format = c("long", "wide"),
  continuous_func = NULL,
  discrete_func = c("MedianCentering", "MeanCentering", "ComBat", "removeBatchEffect"),
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  fill_the_missing = NULL,
  par.prior = TRUE,
  covariates_cols = NULL,
  min_measurements = 8,
  ...
)
}
\arguments{
\item{data_matrix}{features (in rows) vs samples (in columns) matrix, with
feature IDs in rownames and file/sample names as colnames.
See "example_proteome_matrix" for more details (to call the description,
use \code{help("example_proteome_matrix")})}

\item{sample_annotation}{data frame with:
\enumerate{ \item \code{sample_id_col} (this can be repeated as row names)
  \item biological covariates
  \item technical covariates (batches etc) }.
  See \code{help("example_sample_annotation")}}

\item{batch_col}{column in \code{sample_annotation} that should be used for
batch comparison (or other, non-batch factor to be mapped to color in plots).}

\item{feature_id_col}{name of the column with feature/gene/peptide/protein
ID used in the long format representation \code{df_long}. In the wide
formatted representation \code{data_matrix} this corresponds to the row
names.}

\item{sample_id_col}{name of the column in \code{sample_annotation} table,
where the filenames (colnames of the \code{data_matrix} are found).}

\item{measure_col}{if \code{df_long} is among the parameters, it is the
column with expression/abundance/intensity; otherwise, it is used
internally for consistency.}

\item{order_col}{column in \code{sample_annotation} that determines sample
order. It is used for in initial assessment plots
(\link{plot_sample_mean_or_boxplot}) and  feature-level diagnostics
(\link{feature_level_diagnostics}). Can be `NULL`
   if sample order is irrelevant (e.g. in genomic experiments). For more
   details,
   order definition/inference, see \link{define_sample_order} and
   \link{date_to_sample_order}}

\item{fit_func}{Function used for trend fitting (e.g., \code{"loess_regression"}).}

\item{return_fit_df}{Logical; whether \code{\link{adjust_batch_trend_dm}()}
returns the \code{fit_df} (for curve inspection) alongside the corrected matrix.}

\item{no_fit_imputed}{(logical) whether to use imputed (requant) values, as flagged in
\code{qual_col} by \code{qual_value} for data transformation}

\item{qual_col}{column to color point by certain value denoted
by \code{qual_value}. Design with inferred/requant values in
OpenSWATH output data,
which means argument value has to be set to \code{m_score}.}

\item{qual_value}{value in \code{qual_col} to color. For OpenSWATH data,
this argument value has to be set to \code{2} (this is an \code{m_score}
value for imputed values (requant values).}

\item{min_measurements}{Minimum number of samples per batch required for fitting.}

\item{...}{Additional parameters passed to \code{adjust_batch_trend_df()} and
the chosen \code{fit_func}.}

\item{df_long}{data frame where each row is a single feature in a single
sample. It minimally has a \code{sample_id_col}, a \code{feature_id_col}
and a \code{measure_col}, but usually also an \code{m_score} (in OpenSWATH
output result file). See \code{help("example_proteome")} for more details.}

\item{keep_all}{when transforming the data (normalize, correct) - acceptable
values: all/default/minimal (which set of columns be kept).}

\item{x}{Data in long (\code{data.frame}) or wide (\code{matrix}) form, controlled by \code{format}.}

\item{format}{One of \code{"long"} or \code{"wide"}.}

\item{continuous_func}{e.g. \code{"loess_regression"} or \code{NULL}.}

\item{discrete_func}{batch method name.}

\item{fill_the_missing}{Missing-value policy applied \emph{before} discrete correction.
If \code{NULL} (default), missing values are left as is (no imputation/dropping).
For \code{ComBat}, the matrix must be NA-free — set \code{FALSE} to drop rows with NA
or provide a numeric value to impute. For \code{removeBatchEffect}, NA values in the data
matrix are permitted; however, the design (batch/covariates) must not contain NA.}

\item{par.prior}{Logical; use parametric prior (ComBat) or non-parametric.}

\item{covariates_cols}{Optional character vector of \code{sample_annotation} columns
included in \code{mod} for ComBat (biological or nuisance covariates).}
}
\value{
Returns data in the same format as input (\code{data_matrix} or \code{df_long}).
For long format, original values from \code{measure_col} are preserved in
\code{"preBatchCorr_[measure_col]"} and corrected values are written to
\code{measure_col}.

The function \code{\link{adjust_batch_trend_dm}()}, if \code{return_fit_df = TRUE},
returns a list with:
\enumerate{
  \item \code{corrected_dm} — corrected data matrix
  \item \code{fit_df} — data frame to inspect fitted curves
}
}
\description{
Batch correction of normalized data to bring each feature within each batch
to a comparable scale. The following methods are available:
\enumerate{
  \item \strong{Per-feature centering by median/mean}:
    \code{\link{center_feature_batch}()} — unified API for long (\code{"long"})
    and wide (\code{"wide"}) data via \code{format}, and for medians/means via
    \code{stat}. \emph{Deprecated wrappers}:
    \code{center_feature_batch_medians_df()}, \code{center_feature_batch_means_df()},
    \code{center_feature_batch_medians_dm()}, \code{center_feature_batch_means_dm()}
    now forward to \code{center_feature_batch()} and emit deprecation warnings.

  \item \strong{Discrete batch correction with ComBat}:
    \code{\link{correct_with_ComBat}()} adjusts for discrete batch effects
    using parametric or non-parametric empirical Bayes (Johnson et al., 2007).
    \strong{Missing data:} ComBat requires an \emph{NA-free} matrix. If your data
    contain missing values, either set \code{fill_the_missing = FALSE} to drop
    NA-containing features/columns or provide a numeric value to impute before
    calling ComBat.

  \item \strong{Linear batch correction with limma}:
    \code{\link{correct_with_removeBatchEffect}()} removes linear batch effects
    via \code{limma::removeBatchEffect}. \strong{Missing data:} NA values in the
    \emph{expression/intensity matrix} are allowed; the \emph{design matrix}
    (batch/covariates) must be free of missing values.

  \item \strong{Continuous drift correction}:
    \code{\link{adjust_batch_trend_df}()} fits and removes within-batch trends
    (e.g., LOESS) and is typically followed by a discrete adjustment such as
    \code{center_feature_batch()}, \code{correct_with_ComBat()}, or
    \code{correct_with_removeBatchEffect()}.
}

Alternatively, use the wrapper \code{\link{correct_batch_effects}()} to
combine continuous and/or discrete corrections in one call.

Adjust batch signal trend with the custom (continuous) fit.
Should be followed by discrete corrections,
e.g. \code{center_feature_batch_medians_df()} or \code{correct_with_ComBat_df()}.
Available for both long format data frame (\code{adjust_batch_trend_df()})
and data matrix (\code{adjust_batch_trend_dm()}).

Optional continuous drift removal + discrete adjustment
via \code{"MedianCentering"}, \code{"MeanCentering"}, \code{"ComBat"},
or \code{"removeBatchEffect"}. Works for long or wide via \code{format}.
}
\examples{
# Load example data
data(
    list = c("example_sample_annotation", "example_proteome"),
    package = "proBatch"
)

# 1) Per-feature centering (LONG): medians
median_centered_df <- center_feature_batch(
    x = example_proteome,
    sample_annotation = example_sample_annotation,
    format = "long", stat = "medians",
    sample_id_col = "FullRunName", batch_col = "MS_batch",
    feature_id_col = "peptide_group_label", measure_col = "Intensity"
)

# 2) Per-feature centering (WIDE): means
data(example_proteome_matrix, package = "proBatch")
mean_centered_mat <- center_feature_batch(
    x = example_proteome_matrix,
    sample_annotation = example_sample_annotation,
    format = "wide", stat = "means",
    sample_id_col = "FullRunName", batch_col = "MS_batch",
    feature_id_col = "peptide_group_label", measure_col = "Intensity"
)

# 3) ComBat (discrete) — drop NA features/samples first if needed
combat_corrected_df <- correct_with_ComBat(
    x = example_proteome,
    sample_annotation = example_sample_annotation,
    format = "long",
    fill_the_missing = FALSE
)

# 4) Continuous drift correction (LOESS), then discrete centering if desired
test_peptides <- unique(example_proteome$peptide_group_label)[1:3]
test_df <- subset(example_proteome, peptide_group_label \%in\% test_peptides)
adjusted_df <- adjust_batch_trend_df(
    df_long = test_df,
    sample_annotation = example_sample_annotation,
    span = 0.7, min_measurements = 8
)
plot_fit <- plot_with_fitting_curve(
    unique(adjusted_df$peptide_group_label),
    df_long = adjusted_df, measure_col = "preTrendFit_Intensity",
    fit_df = adjusted_df, sample_annotation = example_sample_annotation
)

# 5) One-call wrapper (continuous + discrete)
batch_corrected_matrix <- correct_batch_effects(
    x = example_proteome, sample_annotation = example_sample_annotation,
    format = "long",
    continuous_func = "loess_regression",
    discrete_func = "MedianCentering",
    batch_col = "MS_batch",
    span = 0.7, min_measurements = 8
)

}
\references{
Johnson WE, Li C, Rabinovic A (2007). Adjusting batch effects in microarray
expression data using empirical Bayes methods. \emph{Biostatistics} 8(1):118–127.
Smyth GK (2025). \emph{limma User's Guide}, Bioconductor (see removeBatchEffect / lmFit).
Leek JT et al. (2024). \emph{sva} vignette, Bioconductor.
}
\seealso{
\code{\link{center_feature_batch}},
\code{\link{adjust_batch_trend_df}},
\code{\link{adjust_batch_trend_dm}},
\code{\link{correct_with_ComBat}},
\code{\link{correct_with_removeBatchEffect}},
\code{\link{correct_batch_effects}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}
}
