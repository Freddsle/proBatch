% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/correct_batch_effects copy.R,
%   R/correct_batch_effects.R
\name{correct_batch_effects}
\alias{correct_batch_effects}
\alias{center_feature_batch_medians_dm}
\alias{center_feature_batch_means_dm}
\alias{center_feature_batch_means_df}
\alias{center_feature_batch_medians_df}
\alias{adjust_batch_trend_df}
\alias{adjust_batch_trend_dm}
\alias{correct_with_ComBat_df}
\alias{correct_with_ComBat_dm}
\alias{correct_batch_effects_df}
\alias{correct_batch_effects_dm}
\alias{correct_with_removeBatchEffect_df}
\title{Batch correction of normalized data}
\usage{
center_feature_batch_medians_dm(
  data_matrix,
  sample_annotation,
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity"
)

center_feature_batch_means_dm(
  data_matrix,
  sample_annotation,
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity"
)

center_feature_batch_means_df(
  df_long,
  sample_annotation = NULL,
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  keep_all = "default",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL
)

center_feature_batch_medians_df(
  df_long,
  sample_annotation = NULL,
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  keep_all = "default",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL
)

adjust_batch_trend_df(
  df_long,
  sample_annotation = NULL,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  fit_func = "loess_regression",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

adjust_batch_trend_dm(
  data_matrix,
  sample_annotation,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  fit_func = "loess_regression",
  return_fit_df = TRUE,
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

correct_with_ComBat_df(
  df_long,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  par.prior = TRUE,
  fill_the_missing = NULL,
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  keep_all = "default"
)

correct_with_ComBat_dm(
  data_matrix,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  par.prior = TRUE,
  fill_the_missing = NULL
)

correct_batch_effects_df(
  df_long,
  sample_annotation,
  continuous_func = NULL,
  discrete_func = c("MedianCentering", "MeanCentering", "ComBat", "removeBatchEffect"),
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  fill_the_missing = NULL,
  min_measurements = 8,
  ...
)

correct_batch_effects_dm(
  data_matrix,
  sample_annotation,
  continuous_func = NULL,
  discrete_func = c("MedianCentering", "MeanCentering", "ComBat"),
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  min_measurements = 8,
  no_fit_imputed = TRUE,
  fill_the_missing = NULL,
  ...
)

correct_with_removeBatchEffect_df(
  df_long,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  covariates_cols = NULL,
  fill_the_missing = NULL,
  keep_all = "default",
  ...
)

adjust_batch_trend_dm(
  data_matrix,
  sample_annotation,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  fit_func = "loess_regression",
  return_fit_df = TRUE,
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

adjust_batch_trend_df(
  df_long,
  sample_annotation = NULL,
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  fit_func = "loess_regression",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  min_measurements = 8,
  ...
)

correct_with_ComBat_df(
  df_long,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  par.prior = TRUE,
  fill_the_missing = NULL,
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  keep_all = "default"
)

correct_with_ComBat_dm(
  data_matrix,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  par.prior = TRUE,
  fill_the_missing = NULL
)

correct_batch_effects_df(
  df_long,
  sample_annotation,
  continuous_func = NULL,
  discrete_func = c("MedianCentering", "MeanCentering", "ComBat", "removeBatchEffect"),
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  keep_all = "default",
  no_fit_imputed = TRUE,
  qual_col = NULL,
  qual_value = NULL,
  fill_the_missing = NULL,
  min_measurements = 8,
  ...
)

correct_batch_effects_dm(
  data_matrix,
  sample_annotation,
  continuous_func = NULL,
  discrete_func = c("MedianCentering", "MeanCentering", "ComBat"),
  batch_col = "MS_batch",
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName",
  measure_col = "Intensity",
  order_col = "order",
  min_measurements = 8,
  no_fit_imputed = TRUE,
  fill_the_missing = NULL,
  ...
)

correct_with_removeBatchEffect_df(
  df_long,
  sample_annotation = NULL,
  feature_id_col = "peptide_group_label",
  measure_col = "Intensity",
  sample_id_col = "FullRunName",
  batch_col = "MS_batch",
  covariates_cols = NULL,
  fill_the_missing = NULL,
  keep_all = "default",
  ...
)
}
\arguments{
\item{data_matrix}{features (in rows) vs samples (in columns) matrix, with
feature IDs in rownames and file/sample names as colnames.
See "example_proteome_matrix" for more details (to call the description,
use \code{help("example_proteome_matrix")})}

\item{sample_annotation}{data frame with:
\enumerate{ \item \code{sample_id_col} (this can be repeated as row names)
  \item biological covariates
  \item technical covariates (batches etc) }.
  See \code{help("example_sample_annotation")}}

\item{sample_id_col}{name of the column in \code{sample_annotation} table,
where the filenames (colnames of the \code{data_matrix} are found).}

\item{batch_col}{column in \code{sample_annotation} that should be used for
batch comparison (or other, non-batch factor to be mapped to color in plots).}

\item{feature_id_col}{name of the column with feature/gene/peptide/protein
ID used in the long format representation \code{df_long}. In the wide
formatted representation \code{data_matrix} this corresponds to the row
names.}

\item{measure_col}{if \code{df_long} is among the parameters, it is the
column with expression/abundance/intensity; otherwise, it is used
internally for consistency.}

\item{df_long}{data frame where each row is a single feature in a single
sample. It minimally has a \code{sample_id_col}, a \code{feature_id_col}
and a \code{measure_col}, but usually also an \code{m_score} (in OpenSWATH
output result file). See \code{help("example_proteome")} for more details.}

\item{keep_all}{when transforming the data (normalize, correct) - acceptable
values: all/default/minimal (which set of columns be kept).}

\item{no_fit_imputed}{(logical) whether to use imputed (requant) values, as flagged in
\code{qual_col} by \code{qual_value} for data transformation}

\item{qual_col}{column to color point by certain value denoted
by \code{qual_value}. Design with inferred/requant values in
OpenSWATH output data,
which means argument value has to be set to \code{m_score}.}

\item{qual_value}{value in \code{qual_col} to color. For OpenSWATH data,
this argument value has to be set to \code{2} (this is an \code{m_score}
value for imputed values (requant values).}

\item{order_col}{column in \code{sample_annotation} that determines sample
order. It is used for in initial assessment plots
(\link{plot_sample_mean_or_boxplot}) and  feature-level diagnostics
(\link{feature_level_diagnostics}). Can be `NULL`
   if sample order is irrelevant (e.g. in genomic experiments). For more
   details,
   order definition/inference, see \link{define_sample_order} and
   \link{date_to_sample_order}}

\item{fit_func}{function used for trend fitting (e.g., \code{"loess_regression"}).}

\item{min_measurements}{minimum number of samples per batch required for fitting.}

\item{...}{additional parameters passed to \code{adjust_batch_trend_df()} and
the chosen \code{fit_func}.}

\item{return_fit_df}{(logical) whether \code{\link{adjust_batch_trend_dm}()}
returns the \code{fit_df} (for curve inspection) alongside the corrected matrix.}

\item{par.prior}{logical; use parametric prior (ComBat) or non-parametric.}

\item{fill_the_missing}{numeric value for imputing missing measurements prior
to correction; if \code{NULL} (default), missing values are left as is; if
\code{FALSE}, rows containing missing values are removed before correction.}

\item{continuous_func}{which function to use for the continuous fit (currently
only \code{"loess_regression"}); set \code{NULL} if order-associated drift
correction is not required.}

\item{discrete_func}{which function to use for discrete batch effects
(\code{"MedianCentering"} / \code{"ComBat"}), used by the wrapper.}
}
\value{
the data in the same format as input (\code{data_matrix} or
\code{df_long}).
For \code{df_long} the data frame stores the original values of
\code{measure_col}
in another column called "preBatchCorr_[measure_col]", and the normalized
values in \code{measure_col} column.

The function \code{adjust_batch_trend_dm()}, if \code{return_fit_df} is
\code{TRUE} returns list of two items:
\enumerate{
  \item \code{data_matrix}
  \item \code{fit_df}, used to examine the fitting curves
}

Returns data in the same format as input (\code{data_matrix} or \code{df_long}).
For long format, original values from \code{measure_col} are preserved in
\code{"preBatchCorr_[measure_col]"} and corrected values are written to
\code{measure_col}.

The function \code{\link{adjust_batch_trend_dm}()}, if \code{return_fit_df = TRUE},
returns a list with:
\enumerate{
  \item \code{corrected_dm} — corrected data matrix
  \item \code{fit_df} — data frame to inspect fitted curves
}
}
\description{
Batch correction of normalized data. Batch correction
brings each feature in each batch to the comparable shape.
Currently the following batch correction functions are implemented:
\enumerate{
  \item Per-feature median centering:
  \code{center_feature_batch_medians_df()}.
  Median centering of the features (per batch median).
  \item correction with ComBat:  \code{correct_with_ComBat_df()}.
Adjusts for discrete batch effects using ComBat. ComBat, described in
Johnson et al. 2007. It uses either parametric or
non-parametric empirical Bayes frameworks for adjusting data for batch
effects. Users are returned an expression matrix that has been corrected for
batch effects. The input data are assumed to be free of missing values
and normalized before batch effect removal. Please note that missing values
are common in proteomics, which is why in some cases corrections like
\code{center_peptide_batch_medians_df} are more appropriate.
  \item Continuous drift correction:  \code{adjust_batch_trend_df()}.
Adjust batch signal trend with the custom (continuous) fit.
Should be followed by discrete corrections,
e.g. \code{center_feature_batch_medians_df()} or
\code{correct_with_ComBat_df()}.
}
Alternatively, one can call the correction function with
\code{correct_batch_effects_df()} wrapper.
Batch correction method allows correction of
continuous signal drift within batch (if required) and adjustment for
discrete difference across batches.

Batch correction of normalized data to bring each feature within each batch
to a comparable scale. The following methods are available:
\enumerate{
  \item \strong{Per-feature centering by median/mean}:
    \code{\link{center_feature_batch}()} — unified API for long (\code{"long"})
    and wide (\code{"wide"}) data via \code{format}, and for medians/means via
    \code{stat}. \emph{Deprecated wrappers}:
    \code{center_feature_batch_medians_df()}, \code{center_feature_batch_means_df()},
    \code{center_feature_batch_medians_dm()}, \code{center_feature_batch_means_dm()}
    now forward to \code{center_feature_batch()} and emit deprecation warnings.
  \item \strong{Discrete batch correction with ComBat}:
    \code{\link{correct_with_ComBat_df}()} adjusts for discrete batch effects
    (Johnson et al., 2007) using parametric or non-parametric empirical Bayes.
    Inputs are expected to be normalized and (ideally) free of missing values.
    Since missingness is common in proteomics, per-feature centering may be
    preferable in some cases.
  \item \strong{Continuous drift correction}:
    \code{\link{adjust_batch_trend_df}()} fits and removes within-batch trends
    (e.g., LOESS); typically followed by a discrete adjustment such as
    \code{center_feature_batch()} or \code{correct_with_ComBat_df()}.
}

Alternatively, use the wrapper \code{\link{correct_batch_effects_df}()} to
combine continuous and/or discrete corrections in one call.

Adjust batch signal trend with the custom (continuous) fit.
Should be followed by discrete corrections,
e.g. \code{center_feature_batch_medians_df()} or \code{correct_with_ComBat_df()}.
Available for both long format data frame (\code{adjust_batch_trend_df()})
and data matrix (\code{adjust_batch_trend_dm()}).
}
\examples{
# Load necessary datasets
data(
    list = c("example_sample_annotation", "example_proteome"),
    package = "proBatch"
)

# Median centering per feature per batch:
median_centered_df <- center_feature_batch_medians_df(
    example_proteome, example_sample_annotation
)

# Correct with ComBat:
combat_corrected_df <- correct_with_ComBat_df(
    example_proteome,
    example_sample_annotation
)

# Adjust the MS signal drift:
test_peptides <- unique(example_proteome$peptide_group_label)[1:3]
test_peptide_filter <- example_proteome$peptide_group_label \%in\% test_peptides
test_proteome <- example_proteome[test_peptide_filter, ]
adjusted_df <- adjust_batch_trend_df(test_proteome,
    example_sample_annotation,
    span = 0.7,
    min_measurements = 8
)
plot_fit <- plot_with_fitting_curve(unique(adjusted_df$peptide_group_label),
    df_long = adjusted_df, measure_col = "preTrendFit_Intensity",
    fit_df = adjusted_df, sample_annotation = example_sample_annotation
)

# Correct the data in one go:
batch_corrected_matrix <- correct_batch_effects_df(example_proteome,
    example_sample_annotation,
    continuous_func = "loess_regression",
    discrete_func = "MedianCentering",
    batch_col = "MS_batch",
    span = 0.7, min_measurements = 8
)

# Load example data
data(
    list = c("example_sample_annotation", "example_proteome"),
    package = "proBatch"
)

# 1) Per-feature centering (LONG): medians
median_centered_df <- center_feature_batch(
    x = example_proteome,
    sample_annotation = example_sample_annotation,
    format = "long", stat = "medians",
    sample_id_col = "FullRunName", batch_col = "MS_batch",
    feature_id_col = "peptide_group_label", measure_col = "Intensity"
)

# 2) Per-feature centering (WIDE): means
data(example_proteome_matrix, package = "proBatch")
mean_centered_mat <- center_feature_batch(
    x = example_proteome_matrix,
    sample_annotation = example_sample_annotation,
    format = "wide", stat = "means",
    sample_id_col = "FullRunName", batch_col = "MS_batch",
    feature_id_col = "peptide_group_label", measure_col = "Intensity"
)

# 3) ComBat (discrete)
combat_corrected_df <- correct_with_ComBat_df(
    example_proteome, example_sample_annotation
)

# 4) Continuous drift correction (LOESS), then discrete centering if desired
test_peptides <- unique(example_proteome$peptide_group_label)[1:3]
test_df <- subset(example_proteome, peptide_group_label \%in\% test_peptides)
adjusted_df <- adjust_batch_trend_df(
    df_long = test_df,
    sample_annotation = example_sample_annotation,
    span = 0.7, min_measurements = 8
)
plot_fit <- plot_with_fitting_curve(
    unique(adjusted_df$peptide_group_label),
    df_long = adjusted_df, measure_col = "preTrendFit_Intensity",
    fit_df = adjusted_df, sample_annotation = example_sample_annotation
)

# 5) One-call wrapper
batch_corrected_matrix <- correct_batch_effects_df(
    example_proteome, example_sample_annotation,
    continuous_func = "loess_regression",
    discrete_func = "MedianCentering",
    batch_col = "MS_batch",
    span = 0.7, min_measurements = 8
)

}
\seealso{
\code{\link{fit_nonlinear}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}

\code{\link{center_feature_batch}}, \code{\link{adjust_batch_trend_df}},
\code{\link{adjust_batch_trend_dm}}, \code{\link{correct_with_ComBat_df}},
\code{\link{correct_batch_effects_df}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}

\code{\link{fit_nonlinear}}, \code{\link{plot_with_fitting_curve}}
}
